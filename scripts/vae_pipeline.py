import os
import numpy as np
import torch
import torch.optim as optim
import torch.nn as nn
from torch.utils.data import DataLoader, TensorDataset
import mne
import toml
import logging
import matplotlib.pyplot as plt
import scipy.signal as signal
from utils import VAE, EarlyStopping

# Load general configuration from the main TOML file
config_fn = 'config.toml'
config = toml.load(config_fn)

np.random.seed(42)  # Set your preferred seed
torch.manual_seed(42)  # For CPU
torch.cuda.manual_seed(42)  # For current GPU
torch.cuda.manual_seed_all(42)  # If you use multiple GPUs

log_dir = config['general']['log_dir']
if not os.path.exists(log_dir):
    os.makedirs(log_dir)

output_dir = config['general']['output_dir']
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Setup logging
logging.basicConfig(filename=os.path.join(log_dir, 'vae_pipeline.log'),
                    level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

def load_single_channel_eeg_data(file_paths, duration=5, ch=0):
    """
    Load and preprocess EEG data from multiple files for a single channel.

    Parameters:
    - file_paths (list of str): List of file paths to EEG data files in FIF format.
    - duration (int, optional): Duration of each window in seconds. Default is 5.
    - ch (int, optional): Index of the channel to load. Default is 0.

    Returns:
    - numpy.ndarray: Array of normalized EEG data windows for the specified channel.
    """
    all_data_appended = []
    for path in file_paths:
        raw = mne.io.read_raw_fif(path, verbose=False)
        sfreq = raw.info['sfreq']
        total_samples = int(sfreq * duration)
        all_data = raw.get_data()
        data = all_data[ch, :]
        num_windows = data.shape[0] // total_samples
        for j in range(num_windows):
            start_sample = j * total_samples
            end_sample = start_sample + total_samples
            if end_sample <= data.shape[0]:
                window = data[start_sample:end_sample]
                window = (window - np.mean(window)) / np.std(window)
                all_data_appended.append(window)
    return np.array(all_data_appended)

def vae_loss(recon_x, x, mu, logvar):
    """
    Compute the loss function for the Variational Autoencoder (VAE).

    Parameters:
    - recon_x (torch.Tensor): Reconstructed input from the decoder.
    - x (torch.Tensor): Original input data.
    - mu (torch.Tensor): Mean from the encoder's latent space.
    - logvar (torch.Tensor): Log variance from the encoder's latent space.

    Returns:
    - torch.Tensor: Scalar loss value combining reconstruction loss and KL divergence.
    """
    BCE = nn.functional.mse_loss(recon_x, x, reduction='sum')
    KLD = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())
    return BCE + KLD


def plot_synthetic_eeg(synthetic_eeg, t, channel, output_dir, participant_id):
    """
    Plot synthetic EEG data for visualization and save the figure.

    Parameters:
    - synthetic_eeg (numpy.ndarray): Synthetic EEG data generated by the VAE.
    - t (numpy.ndarray): Time vector corresponding to the EEG samples.
    - channel (int): Channel number being processed.
    - output_dir (str): Directory where the plot will be saved.
    - participant_id (str): Identifier for the participant.

    Returns:
    - None
    """
    plt.figure(figsize=(10, 6))
    for i in range(3):
        plt.plot(t, synthetic_eeg[i], label=f'Synthetic Epoch {i+1}')
    plt.title(f'Synthetic EEG Data for Channel {channel} (First 3 Epochs)')
    plt.xlabel('Time (s)')
    plt.ylabel('Amplitude')
    plt.legend()
    plt.savefig(os.path.join(output_dir, f"channel_{channel}_synthetic_eeg.png"))
    plt.savefig(os.path.join(output_dir, f"channel_{channel}_synthetic_eeg.pdf"))
    plt.close()

def plot_spectra_comparison(real_eeg, synthetic_eeg, t, channel, output_dir, participant_id):
    """
    Compare and plot the power spectra of real and synthetic EEG data.

    Parameters:
    - real_eeg (numpy.ndarray): Real EEG data from the participant.
    - synthetic_eeg (numpy.ndarray): Synthetic EEG data generated by the VAE.
    - t (numpy.ndarray): Time vector corresponding to the EEG samples.
    - channel (int): Channel number being processed.
    - output_dir (str): Directory where the plot will be saved.
    - participant_id (str): Identifier for the participant.

    Returns:
    - None
    """
    plt.figure(figsize=(12, 8))
    for i in range(3):
        sr = 1000
        freqs, spectrum = signal.welch(real_eeg[i], fs=sr, nperseg=1024)
        plt.subplot(2, 3, i + 1)
        plt.plot(freqs, np.log10(spectrum))
        plt.title(f'Spectrum of Original Epoch {i + 1} for Channel {channel}')
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Magnitude')
        plt.xlim(1, 150)
        plt.ylim(-8, 0)

    for i in range(3):
        freqs, spectrum = signal.welch(synthetic_eeg[i], fs=sr, nperseg=1024)
        plt.subplot(2, 3, i + 4)
        plt.plot(freqs, np.log10(spectrum), color='r')
        plt.title(f'Spectrum of Synthetic Epoch {i + 1} for Channel {channel}')
        plt.xlabel('Frequency (Hz)')
        plt.ylabel('Magnitude')
        plt.xlim(1, 150)
        plt.ylim(-8, 0)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, f"channel_{channel}_synthetic_spectrum.png"))
    plt.savefig(os.path.join(output_dir, f"channel_{channel}_synthetic_spectrum.pdf"))
    plt.close()


def train_vae(epoch, model, train_loader, val_loader, optimizer, early_stopping, participant_id, channel, output_dir, train_losses, val_losses):
    """
    Train the VAE model for one epoch and perform validation.

    Parameters:
    - epoch (int): Current epoch number.
    - model (torch.nn.Module): The VAE model instance.
    - train_loader (DataLoader): DataLoader for the training dataset.
    - val_loader (DataLoader): DataLoader for the validation dataset.
    - optimizer (torch.optim.Optimizer): Optimizer for training.
    - early_stopping (EarlyStopping): EarlyStopping instance to monitor validation loss.
    - participant_id (str): Identifier for the participant.
    - channel (int): Channel number being processed.
    - output_dir (str): Directory where outputs are saved.
    - train_losses (list): List to record training losses.
    - val_losses (list): List to record validation losses.

    Returns:
    - bool: True if training should continue, False if early stopping is triggered.
    """
    model.train()
    train_loss = 0
    for data in train_loader:
        inputs = data[0].to(device)
        optimizer.zero_grad()
        recon_batch, mu, logvar = model(inputs)
        loss = vae_loss(recon_batch, inputs, mu, logvar)
        loss.backward()
        train_loss += loss.item()
        optimizer.step()

    train_losses.append(train_loss / len(train_loader.dataset))

    model.eval()
    val_loss = 0
    with torch.no_grad():
        for data in val_loader:
            inputs = data[0].to(device)
            recon_batch, mu, logvar = model(inputs)
            loss = vae_loss(recon_batch, inputs, mu, logvar)
            val_loss += loss.item()

    val_losses.append(val_loss / len(val_loader.dataset))

    logging.info(f'Epoch {epoch}, Training Loss: {train_loss / len(train_loader.dataset):.4f}, '
                 f'Validation Loss: {val_loss / len(val_loader.dataset):.4f}')

    return not early_stopping.step(val_loss / len(val_loader.dataset))

def generate_synthetic_data(model, n_samples=3000):
    """
    Generate synthetic EEG data using the trained VAE model.

    Parameters:
    - model (torch.nn.Module): The trained VAE model.
    - n_samples (int, optional): Number of synthetic samples to generate. Default is 3000.

    Returns:
    - numpy.ndarray: Array containing synthetic EEG data.
    """
    model.eval()
    synthetic_data = []
    with torch.no_grad():
        for _ in range(n_samples):
            z = torch.randn(1, config['vae']['latent_factors']).to(device)
            generated_sample = model.decoder(z).cpu().numpy().squeeze()
            synthetic_data.append(generated_sample)
    return np.array(synthetic_data)

def plot_overall_loss(train_losses, val_losses, plot_path, participant_id, channel):
    """
    Plot training and validation loss curves and save the figure.

    Parameters:
    - train_losses (list): Recorded training losses over epochs.
    - val_losses (list): Recorded validation losses over epochs.
    - plot_path (str): File path to save the plot.
    - participant_id (str): Identifier for the participant.
    - channel (int): Channel number being processed.

    Returns:
    - None
    """
    plt.figure(figsize=(10, 6))
    epochs = range(1, len(train_losses) + 1)
    plt.plot(epochs, train_losses, label='Training Loss')
    plt.plot(epochs, val_losses, label='Validation Loss')
    plt.xlabel('Epochs')
    plt.ylabel('Loss')
    plt.title(f'Training and Validation Loss for Participant {participant_id}, Channel {channel}')
    plt.legend()
    plt.grid(True)

    # Save the plot as PNG
    plt.savefig(plot_path)
    pdf_path = plot_path.replace(".png", ".pdf")
    plt.savefig(pdf_path)

    plt.close()
    logging.info(f"Saved overall loss plot at {plot_path}")

def main():
    """
    Main function to run the VAE training pipeline and generate synthetic data.

    Processes each channel individually:
    - Loads EEG data.
    - Trains the VAE model.
    - Generates synthetic data.
    - Saves the model and generated data.
    - Produces plots for analysis.

    Returns:
    - None
    """
    # Load participant-specific TOML file
    participant_toml_file = config["fnames"]["ieeg_for_vae_fnames"]
    participant_config = toml.load(participant_toml_file)
    participant_id = config["general"]["vae_participant_id"]

    file_paths = participant_config['files']
    data_len = int(config['data']['duration'] * config['data']['sampling_rate'])

    for ch in range(config['data']['channels']):
        logging.info(f"Processing channel {ch} for participant {participant_id}")
        print(f"Processing channel {ch} for participant {participant_id}")
        model = VAE(data_len).to(device)
        optimizer = optim.Adam(model.parameters(), lr=config['vae']['learning_rate'])

        # Load data
        eeg_data = load_single_channel_eeg_data(file_paths, duration=config['data']['duration'], ch=ch)
        eeg_data = torch.tensor(eeg_data, dtype=torch.float32).unsqueeze(1)

        # Train/Validation split
        train_size = int(0.8 * len(eeg_data))
        val_size = len(eeg_data) - train_size
        train_dataset = TensorDataset(eeg_data[:train_size])
        val_dataset = TensorDataset(eeg_data[train_size:])
        train_loader = DataLoader(train_dataset, batch_size=config['vae']['batch_size'], shuffle=True)
        val_loader = DataLoader(val_dataset, batch_size=config['vae']['batch_size'], shuffle=False)

        # Initialize lists to track losses
        train_losses, val_losses = [], []

        # Training loop
        early_stopping = EarlyStopping(patience=config['vae']['patience'], min_delta=0.001)
        for epoch in range(1, config['vae']['n_epochs'] + 1):
            if not train_vae(epoch, model, train_loader, val_loader, optimizer, early_stopping, participant_id, ch, config['general']['output_dir'], train_losses, val_losses):
                logging.info(f"Early stopping at epoch {epoch}")
                break

        # Plot the overall training and validation loss once training is done
        plot_path = os.path.join(output_dir, f"{participant_id}_channel_{ch}_loss.png")
        plot_overall_loss(train_losses[1:], val_losses[1:], plot_path, participant_id, ch)

        # Save model
        model_save_path = os.path.join(output_dir, f"{participant_id}_vae_channel_{ch}.pth")
        torch.save(model.state_dict(), model_save_path)
        logging.info(f"Model for channel {ch} saved at {model_save_path}")

        # Generate synthetic data
        synthetic_data = generate_synthetic_data(model)
        synthetic_data_save_path = os.path.join(output_dir, f"{participant_id}_synthetic_data_channel_{ch}.npy")
        np.save(synthetic_data_save_path, synthetic_data)
        logging.info(f"Synthetic data for channel {ch} saved at {synthetic_data_save_path}")

        # Generate plots for synthetic data
        t = np.linspace(0, eeg_data.shape[2] / config['data']['sampling_rate'], eeg_data.shape[2], endpoint=False)

        # Plot synthetic EEG data and spectra comparison
        plot_synthetic_eeg(synthetic_data, t, ch, output_dir, participant_id)
        plot_spectra_comparison(eeg_data.cpu().numpy().squeeze(), synthetic_data, t, ch, output_dir, participant_id)


if __name__ == "__main__":
    main()
